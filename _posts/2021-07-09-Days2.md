---
layout : post
title : Tập huấn ngày 2
tags : [practice]
---
# Bài 1 : Dãy con lẻ (ODDSEQ) *up sol sau*

# Bài 2 : Giá trị biểu thức ngoặc (PAREN) *up sol sau*

# Bài 3 : Điều chỉnh lương (SALARY)

![image](https://user-images.githubusercontent.com/69662229/132375004-75f93443-65cc-451a-acaf-c7c49c36cfc4.png)

![image](https://user-images.githubusercontent.com/69662229/132375027-489e6599-67fa-4a3f-a484-91c668379287.png)

**Trâu là chân lý**

- Ta gọi hai mảng nex[i] và prev[i] với ý nghĩa như sau: nex[i] là vị trí tiếp theo nếu i thăng cấp một lần, prev[i] là vị trí tiếp theo nếu i hạ cấp một lần.
- Để tính được mảng nex[i] và prev[i], ta thực hiện duyệt qua dãy và đồng thời lưu các vị trí chưa có nex, prev vào stack. Tại mỗi vị trí i, ta kiểm tra nếu top của stack có mức lương thấp hơn i thì nex[st.top()] = i, đẩy pop phần tử đó ra khỏi stack. Mảng pre làm tương tự. Lưu ý nex[n+1] = n+1, prev[0] = 0.
- Với mỗi truy vấn, ta lần lượt thăng cấp i p[i] lần rồi hạ cấp i q[i] lần và ngược lại. Lấy kết quả max.

**Cải tiến bằng bảng thưa**

- Ta nhận thấy thay vì thăng cấp hoặc hạ cấp từng bậc 1 thì ta có thể nhảy cóc theo 2^i vì mọi số tự nhiên n đều có thể phân tích được dưới dạng tổng của các lúy thừa 2.
- Vì vậy ta cải tiến mảng nex[i][j] với ý nghĩa là vị trí của i nếu ta thăng cấp i 2^j lần, prev[i][j] là vị trí của i nếu ta hạ cấp i 2^j lần.
- nex[i][0] và prev[i][0] ta tính như nex[i], prev[i].
- Với nex[i][j] (j>0) ta nhận thấy nếu thăng cấp i 2^j lần cũng bằng thăng cấp i 2^(j-1) lần rồi lại thăng cấp tiếp 2^(j-1) lần, mà ta đã biết nex[i][j-1] nên ta có công thức tính nex[i][j] như sau: nex[i][j] = nex[nex[i][j-1]][j-1] (có nghĩa là thăng cấp 2^(j-1) lần ở vị trí i đã được thăng cấp 2^(j-1)). Mảng prev[i][j] tương tự.
- Với mỗi p[i], ta cần phân tích thành dạng 2^k1 + 2^k2 + ... + 2^kn (k1 < k2 < ... < kn) và với mỗi ki (i = n -> 1) i = nex[i][ki].
- Với q[i] cũng tính tương tự.

[Code](https://pastebin.com/pxcwpT8Y)
