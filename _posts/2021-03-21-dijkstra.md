---
layout : post
comments : true
tags : dijkstra
published : true
title : Dijkstra - Tìm đường đi ngắn nhất
---
**CTRL + F để tìm bài**

**1. [QBSCHOOL](https://vnoi.info/problems/QBSCHOOL/)**

Gọi d[i] là độ dài đường đi ngắn nhất từ 1 đến i, g[i] là số lượng đường đi độ dài ngắn nhất từ 1 đến i.

Tại một node v, ta có hai trường hợp xảy ra:

- Nếu d[v] > d[u] + uv thì cập nhập lại d[v] và số lượng đường đi ngắn nhất từ 1 tới v chính bằng số lượng ngắn nhất từ 1 tới u -> g[v] = g[u]
- Nếu d[v] = d[u] + uv thì số lượng đường đi ngắn nhất từ 1 tới v cộng thêm số lượng từ 1 tới u -> g[v] += g[u]

Kết quả là d[n] và g[n].

**2. [BINLADEN](https://vnoi.info/problems/BINLADEN/)**

Bài này thực ra là dijkstra bình thường thôi, khó ở chỗ mình xử lý dữ liệu đầu vào như thế nào cho dễ.

[code xử lý input](https://pastebin.com/2hXesYXa)

Code trên xử lý kiểu: quy ước mỗi ô là một số thứ tự, đánh số từ 1 -> (m+1) * n , các đỉnh bắt đầu là đỉnh 1 đến n (tầng trên cùng). Với mỗi ô ta có thể đi qua phải, xuống dưới, qua trái (không cần đi lên làm gì, khá vô dụng) -> số x có thể đi đến số x-1, x+1 và số đứng ngay trên đầu nó. (nhớ xét trường hợp nó đã ở bên rìa)

*Bài này đọc code mẫu dell hiểu gì nên phải ngồi code dài vl :(*

**3. [ROADS](https://vnoi.info/problems/ROADS/)**

Bài này ta chỉ cần tìm thằng đang có giá trị tiền nhỏ nhất ra và xét, nếu d[v] > d[u] + uv và chí phí + chí phí để đi qua v <= k thì ta cập nhập và push vô priority queue.

[Code](https://pastebin.com/GvYzmXgm)

**4. [CENTRE28](https://vnoi.info/problems/CENTRE28/)**

Gọi d1[i] là đường đi min từ 1 -> i, dn[i] là đường đi min từ n -> i.

Gọi g1[i] là số lượng đường đi min từ 1 -> i, gn[i] là số lượng đường đi từ n -> i.

Ta nhận thấy rằng nếu i thuộc trong đường đi ngắn nhất từ 1 đến n thì d1[i] + dn[i] = d1[n] và g1[i] * gn[i] = g1[n]

- Với mỗi đỉnh i bất kì nếu d1[i] + dn[i] > d1[n] thì i có thể làm trung tâm vì không nằm trong đường đi ngắn nhất.
- Với mỗi đỉnh i nếu như g1[i] * gn[i] > g1[n] thì tức là đỉnh i có thể làm trung tâm vì không nằm trong đường đi ngắn nhất.

**5. [PWRFAIL](https://vnoi.info/problems/PWRFAIL/)**

Đầu tiên ta khởi tạo mảng a[i][j] là chi phí cần để nối cột điện i với cột điện j (nếu chi phí quá m thì a[i][j] = +oo)

Sau đó dijkstra bình thường thôi :v 

*Chú ý khi so sánh hai số thực với nhau ta thường + thêm 1 giá trị rất là nhỏ ví dụ như 1e-9*

[Code cũ rích từ thời 2020](https://pastebin.com/E6TResHp)

**6. [BESTSPOT](https://vnoi.info/problems/BESTSPOT/)**

Gọi d[i][j] là độ dài đường đi ngắn nhất từ đỉnh i đến đỉnh j, dijkstra p lần để tính d[i][j].

Với mỗi đỉnh i, ta tính tổng d[i][j] (1 <= j <= p) sau đó lấy trung bình và cập nhập min.

**7. [TRAFFICN](https://vnoi.info/problems/TRAFFICN/)**

Gọi ds[i] là độ dài đường đi ngắn nhất từ s đến i, dt[i] là độ dài đường đi ngắn nhất từ t đến i.

Với mỗi cạnh (u,v) độ dài z được thêm vô, có 2 trường hợp xảy ra:

- Nếu ds[u] + z + dt[v] < ds[n] thì độ dài đường đi ngắn nhất được cập nhập lại là ds[u] + z + dt[v].
- Nếu ds[v] + z + dt[u] < ds[n] thì độ dài đường đi ngắn nhất được cập nhập lại là ds[v] + z + dt[u].

Kết quả là min sau khi cập nhập.

**8. [HIWAY](https://vnoi.info/problems/HIWAY/)**

*Bài này là luồng cực đại nên để sau ôn quốc gia quay lại làm :D*

**9. [QBBUILD](https://vnoi.info/problems/QBBUILD/)**

Đề bài yêu cầu tìm một đồ thị con sao cho nó chứa đủ 4 đỉnh yêu cầu và tổng trọng số các cạnh là nhỏ nhất.

Gọi G = (V, E) là đồ thị đề bài cho, ta cần tìm một đồ thị G' = (V', E') sao cho:

- G' là một **cây**. (điều này làm cho trọng số của đồ thị là nhỏ nhất).
- Các nút lá là 4 đỉnh được yêu cầu trong đề bài.

Ngoài ra ta có một nhận xét nữa về đồ thị dạng cây : **Nếu cây có một đỉnh bậc k thì sẽ có ít nhất k nút lá**.

Từ đó suy ra đồ thị G' sẽ có các dạng như sau:

![image](https://user-images.githubusercontent.com/69662229/112004629-35ce8880-8adf-11eb-87e8-2ac36f3d1593.png)

Để ý thì ta thấy dạng (4) là dạng tổng quát của các dạng còn lại -> ta sẽ thử với mỗi cặp đỉnh (u,v) và lấy res là khoảng cách min từ các đỉnh đặc biệt đến u, v. (1 <= u,v <= n)

[Code](https://pastebin.com/VGMei0VD)

**10. [REVAMP](https://vnoi.info/problems/REVAMP/)**

Gọi d[i][k] là độ dài đường đi ngắn nhất từ bãi cỏ 1 đến bãi cỏ i khi đã sử dụng k đường cao tốc.

Dijkstra từ đỉnh 1, với mỗi đỉnh v ta có hai trường hợp xảy ra:

- Nếu hiện tại đang còn đường cao tốc và d[v][k+1] > d[u][k] thì cập nhập và push vào hàng đợi ưu tiên.
- Nếu hiện tại không còn đường cao tốc và d[v][k] > d[u][k] + uv thì cập nhập và push vào hàng đợi ưu tiên.

Kết quả là d[n][k] (dùng hết k đường cao tốc thì lúc nào cũng nhanh hơn không dùng đường nào)
